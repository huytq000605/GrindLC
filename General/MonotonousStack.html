<div class="content-area__2vnF"><div class="discuss-markdown-container"><p>Before diving into the solution, we first introduce a very important stack type, which is called <strong>monotone stack</strong> .</p><p>
</p><h4><strong>What is monotonous increase stack?</strong></h4>
<p></p><p>Roughly speaking, the elements in the an monotonous increase stack keeps an increasing order.</p><p>
</p><h4><strong>The typical paradigm for monotonous increase stack</strong>:</h4>
<pre><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++){
  <span class="hljs-keyword">while</span>(!in_stk.empty() &amp;&amp; in_stk.top() &gt; A[i]){
    in_stk.pop();
  }
  in_stk.push(A[i]);
}
</code></pre>
<h4><strong>What can  monotonous increase stack do?</strong></h4>
<h5>(1) find the <strong>previous less</strong> element of each element in a vector <strong>with O(n) time</strong>:</h5>
<ul>
<li>What is the previous less element of an element?<br>
For example:<br>
[3, 7, 8, 4]<br>
The previous less element of 7 is 3.<br>
The previous less element of 8 is 7.<br>
<strong>The previous less element of 4 is 3</strong>.<br>
There is no previous less element for 3.</li>
</ul>
<p></p><p>For simplicity of notation, we use abbreviation <strong>PLE</strong> to denote <strong>P</strong>revious <strong>L</strong>ess <strong>E</strong>lement.</p><p>
</p><ul>
<li>C++ code (by slitghly modifying the paradigm):<br>
Instead of directly pushing the element itself, here for simplicity, we push the <strong>index</strong>.<br>
We do some record when  the index is pushed into the stack.</li>
</ul>
<pre><code><span class="hljs-comment">// previous_less[i] = j means A[j] is the previous less element of A[i].</span>
<span class="hljs-comment">// previous_less[i] = -1 means there is no previous less element of A[i].</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">previous_less</span><span class="hljs-params">(A.size(), <span class="hljs-number">-1</span>)</span></span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++){
  <span class="hljs-keyword">while</span>(!in_stk.empty() &amp;&amp; A[in_stk.top()] &gt; A[i]){
    in_stk.pop();
  }
  previous_less[i] = in_stk.empty()? <span class="hljs-number">-1</span>: in_stk.top();
  in_stk.push(i);
}
</code></pre>
<h5>(2) find the <strong>next less</strong> element of each element in a vector with <strong>O(n) time</strong>:</h5>
<ul>
<li>What is the next less element of an element?<br>
For example:<br>
[3, 7, 8, 4]<br>
The next less element of 8 is 4.<br>
<strong>The next less element of 7 is 4</strong>.<br>
There is no next less element for 3 and 4.</li>
</ul>
<p></p><p>For simplicity of notation, we use abbreviation <strong>NLE</strong> to denote <strong>N</strong>ext <strong>L</strong>ess <strong>E</strong>lement.</p><p>
</p><ul>
<li>C++ code (by slighly modifying the paradigm):<br>
We do some record when the index is poped out from the stack.</li>
</ul>
<pre><code><span class="hljs-comment">// next_less[i] = j means A[j] is the next less element of A[i].</span>
<span class="hljs-comment">// next_less[i] = -1 means there is no next less element of A[i].</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">previous_less</span><span class="hljs-params">(A.size(), <span class="hljs-number">-1</span>)</span></span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++){
  <span class="hljs-keyword">while</span>(!in_stk.empty() &amp;&amp; A[in_stk.top()] &gt; A[i]){
    <span class="hljs-keyword">auto</span> x = in_stk.top(); in_stk.pop();
    next_less[x] = i;
  }
  in_stk.push(i);
}
</code></pre>
<hr>
<h4><strong>How can the monotonous increase stack be applied to this problem?</strong></h4>
<p></p><p>For example:<br>
Consider the element <code>3</code> in the following vector:</p><p>
</p><pre><code>                            [<span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]
			     |                    |
	             the previous less       the <span class="hljs-built_in">next</span> less 
	                element of <span class="hljs-number">3</span>          element of <span class="hljs-number">3</span>

</code></pre>
<p></p><p>After finding both <strong>NLE</strong> and <strong>PLE</strong> of <code>3</code>, we can determine  the<br>
distance between <code>3</code> and <code>2</code>(previous less) , and the distance between <code>3</code> and <code>1</code>(next less).<br>
In this example, the distance  is <code>4</code> and <code>3</code> respectively.</p><p>
</p><p><strong>How many subarrays with 3 being its minimum value?</strong><br>
The answer is <code>4*3</code>.</p><p>
</p><pre><code><span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> 
<span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> 
<span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> 
<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> 
<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> 
<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> 
<span class="hljs-number">8</span> <span class="hljs-number">3</span> 
<span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> 
<span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> 
<span class="hljs-number">3</span> 
<span class="hljs-number">3</span> <span class="hljs-number">4</span> 
<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>
</code></pre>
<p></p><p><strong>How much the element 3 contributes to the final answer?</strong><br>
It is <code>3*(4*3)</code>.<br>
<strong>What is the final answer?</strong><br>
Denote by <code>left[i]</code> the distance between element <code>A[i]</code> and its <strong>PLE</strong>.<br>
Denote by <code>right[i]</code> the distance between element <code>A[i]</code> and its <strong>NLE</strong>.</p><p>
</p><p>The final answer is,<br>
<code>sum(A[i]*left[i]*right[i] )</code></p><p>
</p><h4><strong>The solution (One pass)</strong></h4>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>{
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; in_stk_p, in_stk_n;
    <span class="hljs-comment">// left is for the distance to previous less element</span>
    <span class="hljs-comment">// right is for the distance to next less element</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(A.size())</span>, <span class="hljs-title">right</span><span class="hljs-params">(A.size())</span></span>;
		
    <span class="hljs-comment">//initialize</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++) left[i] =  i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++) right[i] = A.size() - i;
		
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++){
      <span class="hljs-comment">// for previous less</span>
      <span class="hljs-keyword">while</span>(!in_stk_p.empty() &amp;&amp; in_stk_p.top().first &gt; A[i]) in_stk_p.pop();
      left[i] = in_stk_p.empty()? i + <span class="hljs-number">1</span>: i - in_stk_p.top().second;
      in_stk_p.push({A[i],i});
			
      <span class="hljs-comment">// for next less</span>
      <span class="hljs-keyword">while</span>(!in_stk_n.empty() &amp;&amp; in_stk_n.top().first &gt; A[i]){
        <span class="hljs-keyword">auto</span> x = in_stk_n.top();in_stk_n.pop();
        right[x.second] = i - x.second;
      }
      in_stk_n.push({A[i], i});
    }

    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, mod = <span class="hljs-number">1e9</span> +<span class="hljs-number">7</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i++){
      ans = (ans + A[i]*left[i]*right[i])%mod;
    }
    <span class="hljs-keyword">return</span> ans;
  }
};

</code></pre>
<h4><strong>The last thing that needs to be mentioned for handling duplicate elements</strong>:</h4>
<p></p><p><strong>Method</strong>: Set <strong>strict less</strong> and <strong>non-strict less</strong>(less than <strong>or equal to</strong>) for finding <strong>NLE</strong> and <strong>PLE</strong> respectively. The order doesn't matter.</p><p>
</p><p>For example, the above code for finding <strong>NLE</strong>  is <strong>strict less</strong>, while <strong>PLE</strong> is actually <strong>non-strict  less</strong>.<br>
<strong>Remark</strong>: Although in both loop conditions  the signs are set as  <code>&gt;</code>, for NLE, we make records <strong>inside</strong> the loop, while  for PLE, records are done <strong>outside</strong> the loop.</p><p>
</p><hr>
<h4><strong>More</strong>:</h4>
<ul>
<li>What can monotonous <strong>decrease</strong> stack  do?</li>
<li>Some applications of monotone (increase/decrease) stack in leetcode:<br>
<a href="https://leetcode.com/problems/Next-Greater-Element-II/description/" rel="ugc">Next Greater Element II</a> (a very basic one)<br>
<a href="https://leetcode.com/problems/Largest-Rectangle-in-Histogram/description/" rel="ugc">Largest Rectangle in Histogram</a>(almost the same as this problem)<br>
<a href="https://leetcode.com/problems/Maximal-Rectangle/description/" rel="ugc">Maximal Rectangle</a>(please do this problem after you solve the above one)<br>
<a href="https://leetcode.com/problems/Trapping-Rain-Water/description/" rel="ugc">Trapping Rain Water</a> (challenge)<br>
<a href="https://leetcode.com/problems/remove-duplicate-letters/description/" rel="ugc">Remove Duplicate Letters</a>(challenge)<br>
<a href="https://leetcode.com/problems/remove-k-digits/description/" rel="ugc">Remove K Digits</a><br>
<a href="https://leetcode.com/problems/create-maximum-number/description/" rel="ugc">Create Maximum Number</a><br>
<a href="https://leetcode.com/problems/132-pattern/description/" rel="ugc">132 Pattern</a>(challenge, instead of focusing on the elements in the stack, this problem focuses on the elements poped from the monotone stack)<br>
<a href="https://leetcode.com/problems/sliding-window-maximum/description/" rel="ugc">sliding window maximum</a>(challenge, monotone <strong>queue</strong>)<br>
<a href="https://leetcode.com/problems/Max-Chunks-To-Make-Sorted-II/description/" rel="ugc">Max Chunks To Make Sorted II</a></li>
</ul>
<p></p><p>Hope this helps.</p></div></div>