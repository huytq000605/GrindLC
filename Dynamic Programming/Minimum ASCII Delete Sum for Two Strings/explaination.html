<div class="container__K-8V"><div class="action-area__3aY4"><div class="container__3-ij container__3r81"><div title="Upvote" class="vote__3Zp9 vote__3btZ" data-is-voted="false"><svg viewBox="0 0 24 24" width="1em" height="1em" class="icon__1Md2"><path fill-rule="evenodd" d="M7 14l5-5 5 5z"></path></svg></div><div title="Vote count" class="count__I8pP count__GRlR"><span>78</span></div><div title="Downvote" class="vote__3Zp9 vote__3btZ" data-is-voted="false"><svg viewBox="0 0 24 24" width="1em" height="1em" class="icon__1Md2"><path fill-rule="evenodd" d="M7 10l5 5 5-5z"></path></svg></div></div></div><div class="post-area__3YJL"><div class="root__3bcS"><a href="/RohanPark" target="_blank"><img alt="RohanPark's avatar" class="avatar__7D9c" src="https://assets.leetcode.com/users/RohanPark/avatar_1620106027.png"></a><div><div><div class="user-info__2b-x"><span class="name__2jm2"><a href="/RohanPark" target="_blank" class="link__Lpjq">RohanPark</a></span><span class="reputation___jPr"><svg viewBox="0 0 24 24" width="1em" height="1em" class="icon__1Md2"><path fill-rule="evenodd" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></svg>1451</span></div><div class="post-info__1K06"><p>Last Edit: October 24, 2020 8:38 AM</p><p class="view-count__dBuq">1.9K VIEWS</p></div></div></div></div><div class="content-area__2vnF"><div class="discuss-markdown-container"><p>before getting onto DP, One must master the art of recurssion<br>
    In this post , WE will learn how to solve this/approach question's on on Dynamic Programming Question</p><p>
    </p><p><strong>Step 1 : Understanding the problem</strong><br>
    In this question we are given two strings , and asked to get the sum of ASCII values, to make string same,<br>
    RE-WORDING question : get the sum of all characters which do not form longest Common Subsequence.</p><p>
    </p><p><strong>Step 2 : Logic Building and Recurrance relation</strong><br>
    <strong>sub step 1 : Analyzing different casses and Logic building</strong><br>
    there can be only two cases</p><p>
    </p><pre><code>case 1 : some ith and jth character matches in both string
    case 2 : it doesn't matches
    
    so we have two casses , lets us <span class="hljs-keyword">analyze</span> them one <span class="hljs-keyword">by</span> one 
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">if</span> <span class="hljs-keyword">some</span> ith <span class="hljs-keyword">and</span> jth <span class="hljs-built_in">character</span> matches <span class="hljs-keyword">then</span> we can reduce the <span class="hljs-keyword">ASCII</span> <span class="hljs-keyword">sum</span> <span class="hljs-keyword">if</span> we <span class="hljs-keyword">include</span> <span class="hljs-keyword">both</span> ith <span class="hljs-keyword">and</span> jth <span class="hljs-built_in">character</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">sequence</span>, so we dont <span class="hljs-keyword">add</span> their<span class="hljs-string">'s ASCII values 
    case 2 : ith and jth character doesn'</span>t matches , so we have <span class="hljs-number">2</span> <span class="hljs-keyword">option</span> <span class="hljs-keyword">for</span> these
        <span class="hljs-keyword">option</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">skip</span> ith <span class="hljs-built_in">character</span> assuming jth <span class="hljs-built_in">character</span> might be useful later <span class="hljs-keyword">on</span> , so we <span class="hljs-keyword">add</span> <span class="hljs-keyword">ASCII</span> <span class="hljs-keyword">of</span> ith <span class="hljs-keyword">and</span> recurr <span class="hljs-keyword">for</span> rest 
        <span class="hljs-keyword">option</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">skip</span> jth <span class="hljs-built_in">character</span> assuming ith matches somewhere late <span class="hljs-keyword">in</span> <span class="hljs-keyword">string</span> , same <span class="hljs-keyword">as</span> <span class="hljs-keyword">option</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> other <span class="hljs-keyword">string</span>
    </code></pre>
    <p></p><p><strong>sub step 2 : gettign basecases and writing recurrence relation</strong><br>
    Base cases</p><p>
    </p><pre><code><span class="hljs-keyword">if</span> string_A <span class="hljs-keyword">or</span> string_B <span class="hljs-keyword">is</span> empty : then our ans <span class="hljs-keyword">is</span> <span class="hljs-built_in">sum</span> of <span class="hljs-built_in">all</span> ASCII of non empty string
    <span class="hljs-keyword">if</span> we have finished strings : our ans <span class="hljs-keyword">is</span> zero
    </code></pre>
    <p></p><p>Recurrance relation</p><p>
    </p><pre><code>if string_a[ ith ] EQUALS string_b [jth] // skip these as these will definately <span class="hljs-keyword">help</span> <span class="hljs-keyword">in</span> making <span class="hljs-keyword">string</span> same , <span class="hljs-keyword">and</span> <span class="hljs-keyword">help</span> <span class="hljs-keyword">in</span> reducing <span class="hljs-keyword">sum</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">ASCII</span>
     <span class="hljs-keyword">sum</span> = get_sum_for( string_a ith+<span class="hljs-number">1</span> , string_b jth+<span class="hljs-number">1</span>)
     
    <span class="hljs-keyword">if</span> string_a[ ith ] <span class="hljs-keyword">NOT</span> EQUALS string_b [jth] // <span class="hljs-keyword">then</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">minimum</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> the three options 
    <span class="hljs-keyword">option</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">sum</span> = <span class="hljs-keyword">ASCII</span> <span class="hljs-keyword">of</span> string_a[ith] + get_sum_for( string_a ith+<span class="hljs-number">1</span>, string_b jth)  // assuming jth <span class="hljs-keyword">to</span> be useful
    <span class="hljs-keyword">option</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">sum</span> = <span class="hljs-keyword">ASCII</span> <span class="hljs-keyword">of</span> string_b[jth] + get_sum_for( string_a ith, string_b jth +<span class="hljs-number">1</span>) // assuming ith <span class="hljs-keyword">to</span> be useful
    
    ans = <span class="hljs-keyword">min</span> <span class="hljs-keyword">of</span> ( <span class="hljs-keyword">option</span> <span class="hljs-number">1</span> , <span class="hljs-keyword">option</span> <span class="hljs-number">2</span> )
    </code></pre>
    <p></p><p><strong>step 3 : so now lets code pure Recurssive solution (TLE)</strong></p><p>
    </p><pre><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dead_end_sum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s , <span class="hljs-keyword">int</span> i)</span>
        </span>{
            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>( ; i&lt;s.length() ; i++)
                sum+=<span class="hljs-keyword">int</span>(s[i]);
            <span class="hljs-keyword">return</span> sum;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;a, <span class="hljs-built_in">string</span> &amp;b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>
        </span>{
            <span class="hljs-keyword">int</span> n = a.length();
            <span class="hljs-keyword">int</span> m = b.length();
            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span>(i==n || j==m)
            {
                <span class="hljs-keyword">if</span>(i==n <span class="hljs-keyword">and</span> j==m)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span> (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);   <span class="hljs-comment">// on of the string is empty at this point , remember base case... </span>
            }
        
            <span class="hljs-keyword">if</span>(a[i] == b[j])    <span class="hljs-comment">// 1s case , character matched</span>
                sum = sub(a,b,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);
            <span class="hljs-keyword">else</span>
            {   <span class="hljs-comment">// characters didn't matched ie Our's second case</span>
                sum = min({ sub(a,b,i+<span class="hljs-number">1</span>,j) + <span class="hljs-keyword">int</span>(a[i]) ,                <span class="hljs-comment">// option 1</span>
                            sub(a,b,i,j+<span class="hljs-number">1</span>) + <span class="hljs-keyword">int</span>(b[j]) });               <span class="hljs-comment">// option 2</span>
            }      
            <span class="hljs-keyword">return</span> sum;
        }
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>{
            
            <span class="hljs-keyword">return</span> sub(a,b,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
            
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    </code></pre>
    <p></p><p><strong>step 4 : Convert recurssion to Top-down Dymanic(ACCEPTED)</strong><br>
    so we know we are computing for same sub problems again and again, so what we can do is maintain a matrix to store answers for our subproblem , so if at any point we need to recompute it , we can avoid re-computation by using that value, ( optimizing recurssion )</p><p>
    </p><pre><code><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp; <span class="hljs-comment">// we will store all our answers here and then get values for all future references</span>
        
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dead_end_sum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s , <span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">// one of the string id empty , so all ASCII sums from ith character till end of string</span>
        </span>{
            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>( ; i&lt;s.length() ; i++)
                sum+=<span class="hljs-keyword">int</span>(s[i]);
            <span class="hljs-keyword">return</span> sum;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;a, <span class="hljs-built_in">string</span> &amp;b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> <span class="hljs-comment">// sub problem</span>
        </span>{
            <span class="hljs-keyword">int</span> n = a.length();
            <span class="hljs-keyword">int</span> m = b.length();
            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span>(i==n || j==m)
            {
                <span class="hljs-keyword">if</span>(i==n <span class="hljs-keyword">and</span> j==m)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span> (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);
            }
            
            <span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> dp[i][j];      <span class="hljs-comment">// we know the answer so no need to recompute , reture it as it is.</span>
        
            <span class="hljs-keyword">if</span>(a[i] == b[j])
                sum = sub(a,b,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);
            <span class="hljs-keyword">else</span>
            {
                sum = min({ sub(a,b,i+<span class="hljs-number">1</span>,j) + <span class="hljs-keyword">int</span>(a[i]) ,                <span class="hljs-comment">// option  1</span>
                            sub(a,b,i,j+<span class="hljs-number">1</span>) + <span class="hljs-keyword">int</span>(b[j])});              <span class="hljs-comment">// option 2</span>
            }      
            dp[i][j] = sum;     <span class="hljs-comment">// we store our answer at each step</span>
            <span class="hljs-keyword">return</span> sum;
        }
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>{
            
            <span class="hljs-comment">// making of DP matrix to store result and initilizing it to -1</span>
            dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(a.length()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(b.length()+<span class="hljs-number">1</span> , <span class="hljs-number">-1</span>));
            <span class="hljs-keyword">return</span> sub(a,b,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
            
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    </code></pre>
    <p></p><p><strong>step 5 : so now you know both the approaches , so try coming up with botto up DP yourself.</strong><br>
    <code>hint : strat from base case , go all the way to the top</code><br>
    This is how DP table will look like<br>
    <img src="https://assets.leetcode.com/users/_ro/image_1589998557.png" alt="image"></p><p>
    </p><pre><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>{
            
        <span class="hljs-keyword">int</span> n = a.size();
        <span class="hljs-keyword">int</span> m = b.size();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(n+<span class="hljs-number">1</span> , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; (m+<span class="hljs-number">1</span>));
    
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span> ; i&lt;=n ; i++)                 <span class="hljs-comment">// base case filling up</span>
            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + a[i<span class="hljs-number">-1</span>];
    
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=m ; j++)                 <span class="hljs-comment">// base case filling up</span>
            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + b[j<span class="hljs-number">-1</span>];
    
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span> ; i&lt;=n ; i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span> ; j&lt;=m ; j++)
            {
                <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>])
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];
                <span class="hljs-keyword">else</span>
                    dp[i][j] = min( dp[i<span class="hljs-number">-1</span>][j] + a[i<span class="hljs-number">-1</span>] ,
                                    dp[i][j<span class="hljs-number">-1</span>] + b[j<span class="hljs-number">-1</span>] );
            }
        }
        <span class="hljs-keyword">return</span> dp[n][m];
        }
    </code></pre>
    <p></p><p><strong>thanks for reading</strong><br>
    <strong>previous tutorial on DP</strong><br>
    <a href="https://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve" rel="ugc">https://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve</a><br>
    <a href="https://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP" rel="ugc">https://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP</a></p></div></div><div class="tag-list-container__2cDj"><div class="css-9sdfuf"><span class="css-1oug3j4">dynamic programming</span><span class="css-1oug3j4">memoization</span><span class="css-1oug3j4">top-down</span><span class="css-1oug3j4">recurssion</span></div></div></div></div>